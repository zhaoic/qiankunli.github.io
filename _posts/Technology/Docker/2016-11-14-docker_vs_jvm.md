---

layout: post
title: 纯java项目的公司是否要用docker
category: 技术
tags: Docker
keywords: Docker,jvm

---

## 前言

docker的宗旨是：an open platform to build, ship, and run any app, anywhere。而java也说自己：一次编写，处处运行。

c项目对一些环境有苛刻要求，但对于java项目，为什么一定要用docker呢？对比docker的隔离性，jvm也可以约束自己需要的资源。当然，有些隔离性jvm做不到，但我们貌似也不是特别需要。

我首先想到的是扩容缩容。但仔细想想，依托现有架构，扩容缩容也不是做不到，提高扩容缩容的速度也不是很困难。

对于一个以java项目为主的公司，使用docker的意义何在？


## devops

从devops的角度看，面对一大堆物理机资源，我们想自动化，自动化的前提是规范化。比如，我们要为一个tomcat分配端口，以前是随便分配，现在要根据一定的规则来分配。

从整个devops的生命周期来说，要规范化的东西很多，docker在运行环境这块打包了一下，这个过程可以用Dockerfile来描述。但即便不用docker，我们仍然可以做到代码打包完毕后，部署到线上运行（用脚本描述）。

不过docker可以更进一步，你可以在项目的约定位置新增一个配置文件（对于k8s或mesos来说，文件名有所不同），说明该项目应该有几个实例，依赖了什么服务，滚动升级等等。即便如此，我们依然可以优化原来的运维系统，实现我们想要的自动化。

说到底，devops（尤其是针对j2ee项目的）不是有了docker才有的，也就谈不上没有docker就做不到。不同的是，

1. 老的系统更依赖于脚本，新的系统更依赖配置，所以后者更易用、易描述，进而易规范化。
2. 粒度的不同，见下文

## 粒度

对于可移植性，docker的可移植性是os级别的，给个linux环境就可以。正因为如此，container可以在os之间自由的、轻便的“漂移”。而jvm提供的可移植性只是代码的运行本身，并不包含代码的运行环境。这就意味着，代码要搬家，除了移动代码本身，还要移动或适配代码的运行环境。

以移动一个j2ee项目为例：

对于容器，rm container和rmi image，你就可以抹掉一个项目在host上的一切痕迹（特殊配置除外）。在另一个host上run image，就可以给代码安个新家。

而对于传统方式（比如将web项目部署到tomcat上）首先要记录项目与tomcat的位置映射，然后stop tomcat、rm tomcat dir。在新的os上，create tomcat dir,config tomcat。看起来，就麻烦多了。

所以，使用docker之后，我们并不是在做以前做不到的事，但能更简单的做以前的事。比如扩容缩容，传统方式可以通过脚本实现，但扩容时，要创建新的tomcat，缩容时，残留的tomcat目录要清理，这些都不如容器一个命令来的干脆。

同时，上文提到配置比脚本更易用，具体的说，脚本对环境有依赖，比如将一个项目部署在centos上和部署在ubuntu上，可能就有一点不同。而因为封装粒度的不同，对容器就没有这些问题。

