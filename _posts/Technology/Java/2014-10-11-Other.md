---

layout: post
title: java中的一些点
category: 技术
tags: Java
keywords: JAVA

---

## 前言 ##

我学东西有一个癖好，就是特不喜欢将语法当规则看，最烦听到“你不用管为什么，记着就行了”。碰到这种情况，我要么将这个知识点和其它知识点关联起来，要么就把底层原理搞清楚，实在不行，就选择忘掉。因为既然是死记硬背，总有忘的时候。

## 面向对象和面向过程 ##

我一直有一个比方，如果把程序员写程序比作史官写历史，那么面向过程就是编年体通史，而面向对象更像是纪传体通史。编年体通史以时间（或一段时间）为中心，

    公元xxx年，xxx攻打xxx，克xx城
    公元xx年，xx卒
    
而纪传体通史则以人物为中心，譬如《史记》的《高祖本纪》等。类似的，面向过程多认为程序由一个个函数组成（依照顺序先后调用），譬如历史由一件件大事组成。而面向对象倾向于认为程序由一个个对象组成，譬如历史由一个个人的故事组成。

有一个经典等式，程序 = 数据结构 + 算法。将这句话不准确的引申，那就是程序是一些数据结构和操作这些数据结构的“函数”组成。而观察对象的结构，对象何尝不是一个小级别的“程序”，有自己的数据结构和函数。由此观之，面向对象相对于面向过程抽象级别更高，从机器底层的越往上抽象，就越接近于人的思维，比如“继承”等一系列概念。程序员在设计程序时，就减少了从抽象到具体的思维工作量。

## 反射有什么好 ##

近日在读《程序员的自我修养》，看到动态链接一章，对java反射以及为什么要反射有了更深的认识。书中提到，程序可以利用特定的api在运行时将某些共享对象（比如windows中的dll）加载到内存中（注意，此时程序已经在内存中运行了），我们根据函数的名字拿到了共享对象中对应函数在内存中的地址。问题是光知道地址没有用，因为我们不知道函数签名（比如函数参数类型，返回值类型等，c/c++编译器没有将这些信息保存到共享对象中）。

因为jvm中保存了类的类型信息，所以java不存在这样的问题。重要的是，上述文字讲明白了为什么要反射？我一直有一个疑惑，从直观的感觉看，java反射带来的变化是：给出一个类的名字（比如字符串），就可以创建一个该类的实例，并调用其方法。这样做跟直接创建一个该类的对象并调用方法有什么不同呢？差别就在，对于后者，该类的Class实例及实例本身在程序被加载时（或初始化时）便已被加载到jvm中，而反射则是在程序运行到相关代码时才加载该类的Class实例（在方法区中）及实例本身（在堆中）。

假定如下代码，采用反射的一个好处便是


    // XXX xxx = new XXX(); 直接创建类实例
    xx
    if(condition){
        加载类的实例
    }
    xx
如果condition条件不满足，那么从程序加载到退出，该类的Class实例及实例本身都不用创建，可以节省内存空间（这也是spring带来的一个优点之一）。当然，如果condition条件满足，反射方式由于多了加载过程，与“直接创建类实例”方式相比，处理时间稍长。


## final ##

不变的变量，其实，C语言中也有类似的

1. `#define PI　3.14f`
2. `const float pi=3.14f`

在java中，这个活由final来完成。Java常量定义的时候，就需要对常量进行初始化，同时还有一些细节：


以下代码引用自[http://developer.51cto.com/art/200907/136830.htm][]

    Private static Random rd1=new Random(); //实例化一个随机数生成对象，类成员，类生命周期只初始化一次，可以更改引用。   
    Private final int int1=rd1.nestInt(10); //生成随机数并赋值给常量int1，实例成员，每次对象创建都运行一次，每个对象的int1值可能不同   
    Private static final int int2=rd1.nestInt(10); //生成随机数并赋值给常量int2，类成员，类生命周期只初始化一次，不可以更改值

## String ##

如果是关于String的知识点，从虚拟机实现原理到开发中的应用技巧，我觉得都快够写一本书了。

String可以被继承么？


## 集合

如果知道集合的最大容量，如何更好的初始化。

    Map<String, Object> map = new HashMap<String, Object>((int) (totalCount / 0.75));

[http://developer.51cto.com/art/200907/136830.htm]: http://developer.51cto.com/art/200907/136830.htm

## 内部类

1. 实现多继承
2. 内部类提供了更好的封装，除了所在外围类，其他类都不能访问。例如zookeeper client中的 zookeeper的ZKWatchManager.

