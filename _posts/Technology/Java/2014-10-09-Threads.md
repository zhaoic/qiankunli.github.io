---

layout: post
title: 多线程
category: 技术
tags: Java
keywords: 多线程 JAVA

---

## 前言 

关于多线程这块，要是看书，一会儿说一个类，一会儿讲一个知识点，感觉很快就被带入细节中。所以本篇讲讲我对java多线程的一个初略理解，应该讲的都是“人话”。

## 操作系统中的线程

### 单线程

我们如何影响线程的行为呢？

1. 创建它：继承Thread，实现Runnable，实现TimerTask（现在不推荐）
2. 启动它：start
3. 暂停它（唤醒它）：sleep（自动唤醒），wait和notify
4. 停止它（取消它）：
    
    a. interrupt，注意这种停止并不是抢占式的，代码中要遵守一定的约定。
    
    b. 设置一个变量（显式的interrupt）
        
        class thread{
            public boolean isRun = "true";
            void run(){
                 while(isRun){
                     xx
                 }
            }
            void stop(){
                isRun = false;
            }
        }
       


### 多线程

多个线程同时执行时，有以下几种可能：

1. 乱序执行

    ![Alt text](/public/upload/java/threads_wuxu.png)    
2. 协作执行（部分有序）

    - 某一部分不能被中断
 
        ![Alt text](/public/upload/java/threads_bufenyouxu.png)  
      
    - 部分有序的
  
        ![Alt text](/public/upload/java/threads_bufenyouxu2.png)  
   

3. 有序执行（执行完一个，再执行另一个）
    
    比如java的join方法

So，从乱序、部分有序、到有序执行，这是一个渐近的过程。这也从另一个侧面证明，java的多线程程序，本质上就是在线性程序上加了一些限定。

从另一个角度讲，找出串行化代码的可并行部分，并将其分解到各个线程中，本身就是一种**降低程序复杂度的方式**。考虑到多线程还有线程切换和同步的开销，串行代码并行化，并不是越多越好。

这比起现在新兴的、原生支持多核和并行化的编程语言（比如Go语言），逊色不少。

那么在串行代码并行化的过程中，带来了一些问题（集中在线程交叉的部位）。因为涉及到java内存模型等方面，这个复杂性并不比当年单道OS改成支持多道任务的OS时低。

1. 原子性，有些操作一旦开始执行就不能被打断，在多线程领域则是某个时刻只能有一个线程进入临界区。
2. 可见性，一个线程对变量或对象的改变必须及时让其它线程知道。而每个线程都有自己的缓存，不加处理的话就会破坏这一点。
3. 有序性。某些操作必须是有序的。比如只有当jvm初始化对象的线程将对象初始化完毕了，才允许其它线程访问该对象。而java代码编译和执行时会进行指令重排序，一个方法内后面的代码有可能跑到前面执行，cpu也可能在还未执行完一个方法时，执行下一个方法的指令（因为cpu只看到一个指令序列，而不是人类看到的代码执行和方法跳转）。

### 锁与线程同步

锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。**因为缓存（cpu缓存、基于java机制的线程工作内存）等原因，可见性并不是天然保证的。**

线程的运行需要一定的资源，硬件如打印机、磁盘、数据库和显示屏等，软件如变量等数据结构（其实就是某个特定的内存资源），因为大家都在使用，所以并不能确保资源“申请即得到（这里描述为“可以访问”）”，“得到即可用（这里描述为可以使用）”。

硬件资源的分配，由操作系统提供。而软件资源的分配与协调则由开发人员通过代码主动控制。

锁与同步，本质上都是通过程序，人为的改变线程的状态（由运行改为挂起），**都是通过线程的挂起和恢复机制**。

1. 从表象上看，锁的lock和unlock在一个代码块中，而同步的wait和notify在不同的代码块。**锁，侧重于两个线程的竞争。同步，侧重于两个线程的协作**
2. 锁只是负责资源的独占访问，但该资源是否**语义上可用**，并不保证。比如现在没有其他线程访问资源池，消费者线程可以访问资源池，但资源池没有资源时，消费者线程也是需要等待的。因而锁的应用场景比较通用和固定，程序语言可以方便的进行抽象。
2. 线程同步，确保了线程**在语义上**可以使用共享资源。当线程访问共享资源，检测语义不满足（标志位被占用），会被挂起，需要协作线程满足语义后，触发当前线程的继续执行。但因为应用场景多种多样，所以由开发人员手动写入线程挂起和恢复代码。
3. 但线程同步时判断资源在语义上是否可用之前，必须先锁定（保护）描述语义的变量值。**管理状态依赖性的机制必须与确保状态一致性的机制（锁）关联起来**（来自《Java并发编程实战》）

## C语言中的多线程

看看C语言下写多线程程序什么感觉


        #include <stddef.h>
        #include <stdio.h>
        #include <unistd.h>
        #include <pthread.h>		//用到了pthread库
        #include <string.h>
        void print_msg(char *ptr);
        int main(){
            pthread_t thread1, thread2;
            int i,j;
            char *msg1="do sth1\n";
            char *msg2="do sth2\n";
            pthread_create(&thread1,NULL, (void *)(&print_msg), (void *)msg1);
            pthread_create(&thread2,NULL, (void *)(&print_msg), (void *)msg2);
            sleep(1);
            return 0;
        }
        void  print_msg(char *ptr){
            int retval;
            int id=pthread_self();
            printf("Thread ID: %x\n",id);
            printf("%s",ptr);
            pthread_exit(&retval);
        }
    
从c语言中线程的代码实例和操作系统的基本原理（进程通常是执行一个命令，或者是fork），我们可以看到，线程可以简单的认为是在执行一个函数。

在线程的世界里，其实没有对象这回事。所以在java中，我们考虑多线程程序时，要转换思路。

1. 原来，我会想，执行这个方法的是对象
2. 现在我会想，执行这个方法的，是一个线程。根据程序现在的状态，我是停掉它，还是让它继续运行，亦或是否要通知其它线程。


## java提供的多线程

1. 从代码的感觉上讲，我经常很困惑，比如

        class ThreadA extends Thread{
            public void run(){
                codeA;
                threadb.join();    //threadB.join()的意思是向threadB发送jion消息，加入到当前线程中来，threadB完事执行codeB;
                codeB;
            }
        }
        class MyThread extends Thread{
            public void run(){
                synchronized(b){
                     xx
                     b.wait();    //此处是将当前线程挂起
                }
            }
        }

我的直观感觉是：挂起当前线程，应该是当前线程thread应提供一个方法wait，然后thread.wait()。而事实是通过锁对象的wait方法做到的，也就是通过非线程对象的操作改变了线程对象的状态，我在**ThreadLocal小结**中也提到了类似的情形。原因便是：任何一个方法在执行时都可以通过Thread.currentThread()获取当前线程对象，从而通过线程对象对线程进行一定操作。如果这种感觉不爽，可以显式的使用Condition的await的和signal方法。


## java线程池

笔者刚实习的时候，创建一个线程用的是`new thread(xx).start()`。那么从代码结构的设计等角度，应该减少这类使用，更多应该考虑

1. 通过线程池控制代码的并发量
2. 如何优雅的与spring等框架结合，比如使用quartz（这样还可以更好的控制线程的生命周期，以及事件通知等）

对于一个简单的java线程池

1. 线程池初始化时，即启动其管理的所有线程
2. 线程池中的线程运行逻辑：

    1. 从任务队列中取任务（取不到任务会阻塞）
    2. 执行任务
    3. 转至步骤1


注意：

1. 线程池中的线程跟线程池要执行的任务（我们习惯为让任务成为一个Runnable对象，但实际上这个任务是什么类型都可以）运行逻辑不一样。

2. 线程池中的线程所执行的任务，不是线程池赋予的，而是线程自己“取”的


## java并发小结

java并发的发展历程

1. 使用原始的synchronized关键字，wait和notify等方法，实现锁和同步。

2. jkd1.5和jdk1.6提供了concurrent包，包含Executor，高效和并发的数据容器，原子变量和多种锁。更多的封装减少了程序员自己动手写并发程序的场景，并提供lock和Condition对象的来替换替换内置锁和内置队列。

3. jdk1.7提供ForkJoinTask支持，还未详细了解，估计类似于MapReduce，其本身就是立足于编写可并行执行程序的。

通过阅读《java并发编程实战》全书的脉络如下

1. 什么是线程安全，什么导致了线程不安全？
2. 如何并行程序串行化，常见的并行化程序结构是什么？Executor，生产者消费者模式
3. 如何构造一个线程安全的类（提高竞争效率），如何构造一个依赖状态的类（提高同步效率）？提高性能的手段有哪些？ 使用现有工具类 or 扩充已有父类？

性能优化的基本点就是：减少上下文切换和线程调度（挂起与唤醒）操作。从慢到快的性能对比：

1. synchronized操作内置锁，wait和notify操作内置队列。考虑到现在JVM对其实现进行了很大的优化，其实性能也还好。
2. AQS及AQS包装类
3. Lock和Condition（如果业务需要多个等待线程队列的话）

从上到下，jvm为我们做的越少，灵活性越高，更多的问题要调用者自己写在代码里（执行代码当然比劳烦jvm和os效率高很多），使用的复杂性越高。



